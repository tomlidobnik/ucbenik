<!DOCTYPE HTML>
<html lang="si" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programiranje</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Programiranje</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tomlidobnik/ucbenik" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="uvod"><a class="header" href="#uvod">Uvod</a></h2>
<p>Ta učbenik je namenjen študentom in študentkam, ki se prvič učijo programski jezik C++. Predstavlja osnovne pojme jezika, razlaga namen posameznih delov kode in ponuja spremno razlago.</p>
<p>Zelo priporočljivo je sprotno preizkušanje programov, najlažje na spletni strani <a href="https://www.online-cpp.com">https://www.online-cpp.com</a>. Vsakič, ko vidite kodo v učbeniku, jo kopirajte in zaženite, nato pa opazujte izhod programa. Spreminjajte parametre, vrednosti ali dodajajte svojo kodo, da boste bolje razumeli delovanje programa.</p>
<p>Za reševanje nalog iz učbenika ne uporabljajte orodij, kot je chatGPT. Samostojno reševanje je najboljši način za učenje. Če se pri kakšni nalogi zataknete, najdete rešitve in usmeritve v učbeniku.</p>
<p>Gradivo je pripraviljeno s strani Tutorjev FERI-ja. Če opazite, da je kakšen pojem nejasen ali kaj manjka, kontaktirajte tutorja za programiranje, da se vsebina lahko posodobil.</p>
<h2 id="struktura-c-programa"><a class="header" href="#struktura-c-programa">Struktura C++ programa</a></h2>
<p>Vsak C++ program potrebuje funkcijo <code>main</code>. Ta funkcija je začetna točka izvajanja. Pogosto boste uporabili knjižnico <code>&lt;iostream&gt;</code>, ki omogoča <code>std::cout</code> in <code>std::cin</code>; podrobnejšo razlago boste našli v poglavju <strong>Vhod, izhod in imenski prostori</strong>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Pozdravljen, svet!" &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<ul>
<li><code>#include &lt;iostream&gt;</code> vključuje zaglavje za standardne vhodno-izhodne tokove.</li>
<li><code>std::cout</code> izpiše besedilo na zaslon; <code>std::endl</code> doda prelom vrstice in izprazni izhodni medpomnilnik.</li>
<li><code>return 0;</code> označi, da se je program končal brez napak.</li>
</ul>
<h2 id="prevajanje-in-zagon"><a class="header" href="#prevajanje-in-zagon">Prevajanje in zagon</a></h2>
<ol>
<li>Kodo zapišemo v datoteko s končnico <code>.cpp</code>.</li>
<li>Prevajalnik (npr. <code>g++</code>) kodo prevede v izvedljiv program.</li>
<li>Nastali program zaženemo in opazujemo rezultat.</li>
</ol>
<p>Primer zaporedja ukazov v terminalu:</p>
<pre><code>g++ pozdrav.cpp -o pozdrav
./pozdrav
</code></pre>
<p>Še vedno lahko uporabite spletno stran <a href="https://www.online-cpp.com">https://www.online-cpp.com</a>, kot je omenjeno zgoraj.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="podatkovni-tipi-in-spremenljivke"><a class="header" href="#podatkovni-tipi-in-spremenljivke">Podatkovni tipi in spremenljivke</a></h1>
<p>Podatkovni tip pove prevajalniku, kakšne vrednosti shranjujemo in katera dejanja so dovoljena. Osnovni tipi v C++ zajemajo cela in decimalna števila, znake, logične vrednosti ter nize.</p>
<h2 id="osnovni-tipi"><a class="header" href="#osnovni-tipi">Osnovni tipi</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Tip</th><th>Primer</th><th>Opis</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>int starost = 25;</code></td><td>Celo število s pozitivnim ali negativnim predznakom</td></tr>
<tr><td><code>long</code></td><td><code>long prebivalci = 2100000;</code></td><td>Celo število z daljšim obsegom od <code>int</code></td></tr>
<tr><td><code>unsigned int</code></td><td><code>unsigned int stKart = 120;</code></td><td>Celo število brez negativnih vrednosti</td></tr>
<tr><td><code>double</code></td><td><code>double temperatura = 36.6;</code></td><td>Decimalno število z dvojno natančnostjo</td></tr>
<tr><td><code>float</code></td><td><code>float casSekund = 12.5f;</code></td><td>Decimalno število z enojno natančnostjo</td></tr>
<tr><td><code>char</code></td><td><code>char znak = 'A';</code></td><td>Posamezen znak, zapisan v enojnih narekovajih</td></tr>
<tr><td><code>bool</code></td><td><code>bool uspeh = true;</code></td><td>Logična vrednost <code>true</code> ali <code>false</code></td></tr>
<tr><td><code>std::string</code></td><td><code>std::string ime = "Ana";</code></td><td>Niz znakov; potrebujemo zaglavje <code>&lt;string&gt;</code> in zapis <code>std::</code></td></tr>
</tbody></table>
</div>
<p>Na večini sodobnih 64-bitnih sistemov <code>int</code> in <code>float</code> zasedeta 32 bitov (4 bajte), <code>long</code> in <code>double</code> pa 64 bitov (8 bajtov). Pri preprostih nalogah in manjših številih razlika običajno ne vpliva na rezultat; pomembna postane šele, ko potrebujemo zelo velike vrednosti ali visoko natančnost.</p>
<h2 id="spremenljivke"><a class="header" href="#spremenljivke">Spremenljivke</a></h2>
<p>Spremenljivka je imenovana shramba vrednosti. Deklaracija pove tip, ime in, po želji, začetno vrednost.</p>
<pre><code class="language-cpp">int steviloTock = 5;      // tip int, ime steviloTock, začetna vrednost 5
double povprecje = 8.75;  // tip double, ime povprecje
</code></pre>
<ul>
<li>Vsaka spremenljivka ima tip, ime (brez presledkov, začnemo z črko ali <code>_</code>) in vrednost.</li>
<li>Dobra praksa je, da ime opiše namen (<code>steviloTock</code>, <code>povprecje</code> ...), kar olajša branje kode.</li>
<li>Če spremenljivke ne inicializiramo, lahko vsebuje naključne podatke; raje jo nastavimo na znano vrednost takoj ob deklaraciji.</li>
</ul>
<h3 id="konstante-const"><a class="header" href="#konstante-const">Konstante (<code>const</code>)</a></h3>
<p>Če pred tip postavimo ključno besedo <code>const</code>, vrednosti po inicializaciji ne smemo več spreminjati.</p>
<pre><code class="language-cpp">const double PI = 3.1415926535;
const int NAJVEC_POSKUSOV = 3;

PI = 2.0;        // napaka: const vrednosti ne moremo spremeniti
</code></pre>
<ul>
<li><code>const</code> zagotovi, da pomembna vrednost ostane nespremenjena, in pomaga prevajalniku ujeti neželene spremembe.</li>
<li>Ime konstante pogosto pišemo z velikimi črkami in podčrtaji (<code>MAX_HITROST</code>), kar jasno pokaže, da gre za nespremenljivo vrednost.</li>
<li><code>const</code> lahko dodamo tudi kazalcem in referencam; o tem več v poglavjih o kazalcih in funkcijah.</li>
</ul>
<p>V naslednjem programu morda še ne boste razumeli uporabe <code>std::cout</code>, operatorja <code>&lt;&lt;</code> in <code>std::endl</code>. To podrobneje razložimo v naslednjem poglavju; za zdaj si zapomnite, da s tem zapisom pošljemo besedilo ali vrednost na standardni izhod (konzolo).</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    unsigned int letoRojstva = 2000; // uporabimo unsigned, saj leto rojstva ne more biti negativno
    double povprecje = 8.75;
    char ocena = 'A';
    bool opravljen = true;
    std::string ime = "Tina";

    std::cout &lt;&lt; "Pozdravljen, " &lt;&lt; ime &lt;&lt; "!" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Letnica rojstva: " &lt;&lt; letoRojstva &lt;&lt; std::endl;
    std::cout &lt;&lt; "Povprečje ocen: " &lt;&lt; povprecje &lt;&lt; std::endl;
    std::cout &lt;&lt; "Ocena: " &lt;&lt; ocena &lt;&lt; std::endl;
    std::cout &lt;&lt; "Status: " &lt;&lt; opravljen &lt;&lt; std::endl; // Izpiše 1 za true
    return 0;
}
</code></pre>
<ul>
<li><code>#include &lt;string&gt;</code> omogoča uporabo tipa <code>std::string</code>.</li>
<li><code>std::cout</code> prihaja iz imenskega prostora <code>std</code>, zato pred imenom dodamo <code>std::</code>.</li>
<li>Tip <code>bool</code> interno shrani 0 za <code>false</code>, kakršna koli druga celoštevilska vrednost pa se pri pretvorbi spremeni v <code>true</code> (običajno 1); pri izpisu se zato <code>true</code> prikaže kot 1 in <code>false</code> kot 0.</li>
<li>Nizi uporabljajo dvojne narekovaje, znaki pa enojne.</li>
</ul>
<h2 id="pretvorbe"><a class="header" href="#pretvorbe">Pretvorbe</a></h2>
<ul>
<li>Pretvorba iz <code>int</code> v <code>double</code> se zgodi samodejno, ker <code>double</code> lahko shrani celo število.</li>
<li>Pretvorba iz <code>double</code> v <code>int</code> odstrani decimalni del (uporabi se odrezava).</li>
<li><code>static_cast&lt;ciljni_tip&gt;(vrednost)</code> je priporočeni način za jasno pretvorbo.</li>
</ul>
<pre><code class="language-cpp">int x = 5;
double y = x;             // y postane 5.0
int z = static_cast&lt;int&gt;(3.9); // z postane 3
</code></pre>
<p>V zadnji vrstici poskrbimo za eksplicitno pretvorbo, da je bralcu jasno, da decimalni del izgine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vhod-izhod-in-imenski-prostori"><a class="header" href="#vhod-izhod-in-imenski-prostori">Vhod, izhod in imenski prostori</a></h1>
<p>V tem poglavju spoznamo knjižnico <code>&lt;iostream&gt;</code>, ki omogoča izpis in branje podatkov prek standardnih tokov, ter koncept imenskih prostorov, s katerim se izognemo poimenovalnim konfliktom.</p>
<h2 id="standardni-tokovi"><a class="header" href="#standardni-tokovi">Standardni tokovi</a></h2>
<p>Knjižnica <code>&lt;iostream&gt;</code> definira tri najpogosteje uporabljene tokove:</p>
<ul>
<li><code>std::cin</code> – standardni vhod (tipkovnica).</li>
<li><code>std::cout</code> – standardni izhod (konzola).</li>
<li><code>std::cerr</code> – standardni izhod za napake.</li>
</ul>
<p>Za nas bosta pomembna <code>std::cin</code> in <code>std::cout</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; "Vnesi celo število: ";

    int stevilo = 0;
    std::cin &gt;&gt; stevilo; // Branje s tipkovnice

    std::cout &lt;&lt; "Vpisal si: " &lt;&lt; stevilo &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<ul>
<li>Operator <code>&lt;&lt;</code> (inserter) podatke iz programa pošlje v tok.</li>
<li>Operator <code>&gt;&gt;</code> (extractor) podatke prebere iz toka v spremenljivko.</li>
<li><code>std::endl</code> doda prelom vrstice in izprazni izhodni medpomnilnik.</li>
</ul>
<h2 id="izbira-med-stdendl-in-n"><a class="header" href="#izbira-med-stdendl-in-n">Izbira med <code>std::endl</code> in <code>"\n"</code></a></h2>
<ul>
<li><code>std::endl</code> doda prelom vrstice in izprazni izhodni medpomnilnik. Uporabimo ga, ko želimo zagotovljen takojšen izpis.</li>
<li>Niz <code>"\n"</code> je hitrejši, ker ne izprazni medpomnilnika; primeren je za običajen izpis v zankah.</li>
<li>Pri preprostih programih razlika ni opazna.</li>
</ul>
<pre><code class="language-cpp">std::cout &lt;&lt; "Pozdrav" &lt;&lt; '\n';
std::cout &lt;&lt; "Takojšen izpis" &lt;&lt; std::endl;
</code></pre>
<h2 id="branje-več-vrednosti"><a class="header" href="#branje-več-vrednosti">Branje več vrednosti</a></h2>
<p>Operator <code>&gt;&gt;</code> preskoči začetne presledke in razčleni vrednosti glede na vrsto spremenljivke.</p>
<pre><code class="language-cpp">std::string ime;
int starost = 0;
double visina = 0.0;

std::cin &gt;&gt; ime &gt;&gt; starost &gt;&gt; visina;
</code></pre>
<ul>
<li><code>std::cin</code> ob prvi napaki preneha brati; preostale spremenljivke ostanejo nespremenjene.</li>
<li>Če vnos ni pravilne oblike, se tok označi z napako (<code>std::cin.fail()</code> vrne <code>true</code>). Takrat moramo napako počistiti s <code>std::cin.clear()</code> in odstraniti neveljaven vnos, na primer s <code>std::cin.ignore()</code>.</li>
</ul>
<h2 id="imenski-prostori"><a class="header" href="#imenski-prostori">Imenski prostori</a></h2>
<p>Vsa imena iz standardne knjižnice (npr. <code>cout</code>, <code>string</code>, <code>cin</code>) živijo v imenskem prostoru <code>std</code>. V praksi imamo dve možnosti:</p>
<ul>
<li>Vsakič napišemo <code>std::cout</code>, <code>std::string</code> in podobno.</li>
<li>Na začetek programa dodamo vrstico <code>using namespace std;</code> in nato pišemo samo <code>cout</code>, <code>string</code> ...</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std; // prihranimo ponavljanje std::

int main() {
    cout &lt;&lt; "Pozdrav" &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>Za male programe je druga možnost priročna. Ko postanejo projekti večji, se pogosto vrnemo k zapisom <code>std::</code>, ker tako takoj vidimo, da uporabljamo standardno knjižnico.</p>
<h2 id="naloge"><a class="header" href="#naloge">Naloge</a></h2>
<ol>
<li>Napiši program, ki izpiše »Pozdravljen svet« trikrat, vsakič v svoji vrstici.
Pričakovani rezultat:
<pre><code>Pozdravljen svet
Pozdravljen svet
Pozdravljen svet
</code></pre>
</li>
<li>Napiši program, ki uporabnika najprej prosi za celo število, nato za decimalno število, na koncu pa izpiše oba vnosa.
Pričakovani rezultat (primer):
<pre><code>Celo število: 5
Decimalno število: 3.2
Vpisali ste številki 5 in 3.2
</code></pre>
V prvih dveh vrsticah uporabnik vnese vrednosti, tretja vrstica je izpis programa.</li>
</ol>
<p>Poskusite tudi z drugimi tipi podatkov, spreminjajte vnesene vrednosti in opazujte, kako se program obnaša.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operatorji"><a class="header" href="#operatorji">Operatorji</a></h1>
<p>Operatorji v C++ opisujejo, kako spremenljivke in vrednosti sodelujejo v izrazih. Poznavanje aritmetičnih, prireditvenih, primerjalnih in logičnih operatorjev je ključno za pisanje uporabnih programov.</p>
<h2 id="aritmetični-operatorji"><a class="header" href="#aritmetični-operatorji">Aritmetični operatorji</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Opis</th><th>Primer</th></tr></thead><tbody>
<tr><td><code>+</code></td><td>Seštevanje</td><td><code>a + b</code></td></tr>
<tr><td><code>-</code></td><td>Odštevanje</td><td><code>a - b</code></td></tr>
<tr><td><code>*</code></td><td>Množenje</td><td><code>a * b</code></td></tr>
<tr><td><code>/</code></td><td>Deljenje</td><td><code>a / b</code> (za cela števila poteka z odrezavo)</td></tr>
<tr><td><code>%</code></td><td>Ostanki pri deljenju</td><td><code>a % b</code> (deluje samo na celih številih)</td></tr>
<tr><td><code>++</code></td><td>Povečaj za 1</td><td><code>++a</code> ali <code>a++</code></td></tr>
<tr><td><code>--</code></td><td>Zmanjšaj za 1</td><td><code>--a</code> ali <code>a--</code></td></tr>
</tbody></table>
</div>
<p>Pri <code>++</code> in <code>--</code> je razlika med predpono in pripono: <code>++a</code> poveča <code>a</code> in vrne novo vrednost, <code>a++</code> pa vrne staro vrednost in šele nato poveča spremenljivko. V enostavnih zankah, kjer rezultat ne beremo, sta obliki enakovredni.</p>
<pre><code class="language-cpp">int a = 10;
int b = 3;
std::cout &lt;&lt; a / b &lt;&lt; std::endl; // Izpiše 3, ker gre za celo deljenje
std::cout &lt;&lt; a % b &lt;&lt; std::endl; // Izpiše 1
a++; // zdaj je a enak 11
</code></pre>
<ul>
<li>Pri celih številih deljenje vedno odreže decimalni del; za natančnejši izračun uporabimo <code>double</code>.</li>
<li>Operator <code>%</code> vrne ostanek pri celem deljenju, to bo uporabno za preverjanje ali je število deljivo z drugim številom ter ali je sodo.</li>
</ul>
<h2 id="prireditveni-operatorji"><a class="header" href="#prireditveni-operatorji">Prireditveni operatorji</a></h2>
<p><code>=</code> prisodi vrednost spremenljivki. Razširjeni operatorji (npr. <code>+=</code>) združijo prirejanje z aritmetiko.</p>
<pre><code class="language-cpp">int x = 5;
x += 2; // je enako kot x = x + 2;
x *= 3; // je enako kot x = x * 3;
</code></pre>
<ul>
<li>Razširjeni operatorji prihranijo ponavljanje spremenljivke na levi strani (<code>x = x + 2</code> postane <code>x += 2</code>).</li>
<li>Enak princip deluje tudi za <code>-=</code>, <code>*=</code>, <code>/=</code> in <code>%=</code>.</li>
</ul>
<h2 id="primerjalni-in-logični-operatorji"><a class="header" href="#primerjalni-in-logični-operatorji">Primerjalni in logični operatorji</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Opis</th></tr></thead><tbody>
<tr><td><code>==</code></td><td>Enako</td></tr>
<tr><td><code>!=</code></td><td>Ni enako</td></tr>
<tr><td><code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></td><td>Relacijski operatorji</td></tr>
<tr><td><code>&amp;&amp;</code></td><td>Logični IN</td></tr>
<tr><td><code>||</code></td><td>Logični ALI</td></tr>
<tr><td><code>!</code></td><td>Logična negacija</td></tr>
</tbody></table>
</div>
<p>Več o pomenih <a href="https://en.wikipedia.org/wiki/Truth_table">logičnih operatorjev</a>.</p>
<pre><code class="language-cpp">int starost = 20;
bool jePolnoleten = starost &gt;= 18;
bool imaDovoljenje = true;
if (jePolnoleten &amp;&amp; imaDovoljenje) {
    std::cout &lt;&lt; "Dostop dovoljen" &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Dostop zavrnjen" &lt;&lt; std::endl;
}

</code></pre>
<ul>
<li>Pogoji v <code>if</code> primerjajo vrednosti; rezultat je logičen tip <code>bool</code>.</li>
<li>Za preverjanje več pogojev kombiniramo operatorja <code>&amp;&amp;</code> (IN) in <code>||</code> (ALI).</li>
<li>Uporaba oklepajev okoli primerjav izboljša berljivost, čeprav imajo <code>&gt;=</code> in <code>&amp;&amp;</code> različne prioritete.</li>
</ul>
<h2 id="presečišče-aritmetike-in-logike"><a class="header" href="#presečišče-aritmetike-in-logike">Presečišče aritmetike in logike</a></h2>
<pre><code class="language-cpp">int tocke = 75;
bool opravljen = (tocke &gt;= 50) &amp;&amp; (tocke &lt;= 100);
bool odlicen = tocke &gt; 90 || tocke == 90;
</code></pre>
<ul>
<li>Oklepaji jasno pokažejo, katera primerjava se izvede najprej, četudi operatorja <code>&gt;=</code> in <code>&amp;&amp;</code> imata različni prioriteti.</li>
<li>V izrazu <code>tocke &gt; 90 || tocke == 90</code> uporabimo <code>||</code>, ker nas zanima katera koli od dveh možnosti.</li>
</ul>
<p>Pazimo, da kombinacija več operatorjev upošteva prioriteto; oklepaji skoraj vedno izboljšajo berljivost.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="krmilni-stavki"><a class="header" href="#krmilni-stavki">Krmilni stavki</a></h1>
<p>Krmilni stavki uravnavajo potek izvajanja programa. Z njimi odločimo, kateri deli kode se bodo izvedli na podlagi pogojev. Za ustvarjanje pogojev potrebujete znanje logičnih operatorjev iz prejšnjega poglavja.</p>
<h2 id="if-in-else"><a class="header" href="#if-in-else"><code>if</code> in <code>else</code></a></h2>
<p><code>if</code> preveri pogoj. Če je pogoj resničen, se izvede blok znotraj oklepajev. <code>else</code> se izvede, ko pogoj ni izpolnjen.</p>
<pre><code class="language-cpp">int starost = 17;

if (starost &gt;= 18) {
    std::cout &lt;&lt; "Dobrodošel med odrasle" &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Še malo potrpi" &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>Pogoj znotraj <code>if</code> mora vrniti logično vrednost (<code>true</code> ali <code>false</code>).</li>
<li>V vsakem bloku lahko napišemo poljubno število stavkov; blok se zaključi z <code>}</code>.</li>
</ul>
<h2 id="verižno-else-if"><a class="header" href="#verižno-else-if">Verižno <code>else if</code></a></h2>
<p>Ko imamo več možnosti, uporabimo <code>else if</code>.</p>
<pre><code class="language-cpp">int tocke = 68;

if (tocke &gt;= 90) {
    std::cout &lt;&lt; "Ocena 5" &lt;&lt; std::endl;
} else if (tocke &gt;= 75) {
    std::cout &lt;&lt; "Ocena 4" &lt;&lt; std::endl;
} else if (tocke &gt;= 60) {
    std::cout &lt;&lt; "Ocena 3" &lt;&lt; std::endl;
} else if (tocke &gt;= 50) {
    std::cout &lt;&lt; "Ocena 2" &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Ocena 1" &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>Več zaporednih <code>else if</code> veji poskrbi, da se izvede samo prvi ujemajoči pogoj.</li>
<li>Pogoji so urejeni od najzahtevnejšega proti najmilejšemu; če bi najprej preverili <code>&gt;= 50</code>, se preostali pogoji ne bi nikoli izvedli.</li>
</ul>
<h2 id="switch"><a class="header" href="#switch"><code>switch</code></a></h2>
<p><code>switch</code> izbere vejo na podlagi vrednosti izrazov tipa <code>int</code>, <code>char</code> ali <code>enum</code>. Uporabljamo <code>break</code>, da preprečimo padanje v naslednje <code>case</code>.</p>
<pre><code class="language-cpp">char izbira = 'b';

switch (izbira) {
    case 'a':
        std::cout &lt;&lt; "Izbral si možnost A" &lt;&lt; std::endl;
        break;
    case 'b':
        std::cout &lt;&lt; "Izbral si možnost B" &lt;&lt; std::endl;
        break;
    default:
        std::cout &lt;&lt; "Neznana možnost" &lt;&lt; std::endl;
        break;
}
</code></pre>
<ul>
<li>Vsak <code>case</code> predstavlja eno možnost; <code>default</code> se izvede, ko ni zadet noben drug primer.</li>
<li>Če izpustimo <code>break</code>, se izvajanje nadaljuje v naslednji <code>case</code> (t. i. »fall-through«).</li>
</ul>
<h2 id="vgnezdeni-pogoji"><a class="header" href="#vgnezdeni-pogoji">Vgnezdeni pogoji</a></h2>
<p>Pogosto kombiniramo pogoje v blokih znotraj drugih blokov. Kratek komentar pomaga ohraniti jasnost, ko je pogojev več.</p>
<pre><code class="language-cpp">int starost = 20;
bool imaKarto = false;

if (starost &gt;= 18) {
    if (imaKarto) {
        std::cout &lt;&lt; "Lahko vstopiš." &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Kupite karto na blagajni." &lt;&lt; std::endl;
    }
} else {
    std::cout &lt;&lt; "Vstop ni dovoljen." &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>Vgnezdeni <code>if</code> se izvede samo, če je zunanji pogoj izpolnjen.</li>
<li>Za boljšo berljivost lahko pogoj znotraj bloka preselimo v ločeno funkcijo (npr. <code>imaDostop()</code>), ko logika postane zahtevnejša.</li>
</ul>
<h2 id="naloge-1"><a class="header" href="#naloge-1">Naloge</a></h2>
<ol>
<li>Napiši program, ki prebere celo število in izpiše, ali je pozitivno, negativno ali enako nič.</li>
<li>Napiši program, ki prebere celo število in izpiše, ali je število sodo.</li>
<li>Napiši program, ki prebere celo število in izpiše, ali je večje od 50. Če je, naj dodatno preveri, ali je deljivo s 5, in to tudi izpiše. Pazite, kako gnezdite <code>if</code> stavke.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zanke"><a class="header" href="#zanke">Zanke</a></h1>
<p>Zanke ponavljajo blok kode, dokler je izpolnjen določen pogoj. To je uporabno, kadar želimo določen del kode izvesti večkrat.</p>
<h2 id="for"><a class="header" href="#for"><code>for</code></a></h2>
<p><code>for</code> zanka združi inicializacijo, pogoj in posodobitev v eni vrstici.</p>
<pre><code class="language-cpp">for (int i = 0; i &lt; 5; ++i) {
    std::cout &lt;&lt; "Ponovitev: " &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>Spremenljivko <code>i</code> ustvarimo znotraj zanke; po izhodu iz zanke ni več dostopna.</li>
<li>Imamo pogoj <code>i &lt; 5</code>, zanka se bo izvajala dokler to ne bo več res.</li>
<li>Posodobitev <code>i++</code> se izvede na koncu vsake ponovitve.</li>
</ul>
<h2 id="while"><a class="header" href="#while"><code>while</code></a></h2>
<p><code>while</code> najprej preveri pogoj in nato izvede telo zanke.</p>
<pre><code class="language-cpp">int stevec = 0;

while (stevec &lt; 3) {
    std::cout &lt;&lt; "Števec: " &lt;&lt; stevec &lt;&lt; std::endl;
    stevec++;
}
</code></pre>
<ul>
<li>Če je pogoj že na začetku neresničen, se telo sploh ne izvede.</li>
<li>Povečamo <code>stevec</code>, sicer bi zanka tekla neskončno dolgo.</li>
</ul>
<h2 id="do-while"><a class="header" href="#do-while"><code>do-while</code></a></h2>
<p><code>do-while</code> najprej izvede telo in šele nato preveri pogoj. Zato se telo vedno izvede vsaj enkrat.</p>
<pre><code class="language-cpp">int poskus = 0;
do {
    std::cout &lt;&lt; "Poskus št. " &lt;&lt; poskus &lt;&lt; std::endl;
    poskus++;
} while (poskus &lt; 2);
</code></pre>
<ul>
<li>Pogoj je na koncu, zato se rezultat izpiše vsaj enkrat, tudi če je <code>poskus &lt; 2</code> že sprva neresničen.</li>
</ul>
<h2 id="gnezdene-zanke"><a class="header" href="#gnezdene-zanke">Gnezdene zanke</a></h2>
<p>Zanko lahko vstavimo v telo druge zanke. Zunanja zanka skrbi za vrstice, notranja pa za stolpce ali ponovitve znotraj vsake vrstice.</p>
<pre><code class="language-cpp">for (int vrstica = 0; vrstica &lt; 3; vrstica++) {
    for (int stolpec = 0; stolpec &lt; 3; stolpec++) {
        std::cout &lt;&lt; "(" &lt;&lt; vrstica &lt;&lt; "," &lt;&lt; stolpec &lt;&lt; ") ";
    }
    std::cout &lt;&lt; std::endl; // prelom vrstice po koncu notranje zanke
}
</code></pre>
<ul>
<li>Spremenljivke <code>vrstica</code> in <code>stolpec</code> sta neodvisni; vsaka se povečuje v svoji zanki.</li>
<li>Notranja zanka se za vsako vrednost <code>vrstica</code> izvede v celoti.</li>
<li>Prelom vrstice postavimo v zunanjo zanko, da dobimo urejen izpis.</li>
</ul>
<h2 id="prekinitve-zanke"><a class="header" href="#prekinitve-zanke">Prekinitve zanke</a></h2>
<ul>
<li><code>break</code> takoj konča zanko.</li>
<li><code>continue</code> preskoči preostanek trenutne iteracije.</li>
</ul>
<pre><code class="language-cpp">for (int i = 0; i &lt; 5; ++i) {
    if (i == 2) {
        continue; // Preskoči 2
    }
    if (i == 4) {
        break; // Zaključi zanko
    }
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li><code>continue</code> preskoči preostalo telo trenutne ponovitve in nadaljuje z naslednjo.</li>
<li><code>break</code> zapusti zanko ne glede na to, ali je pogoj še vedno izpolnjen.</li>
</ul>
<h2 id="naloge-2"><a class="header" href="#naloge-2">Naloge</a></h2>
<ol>
<li>Napiši program, ki izpiše številke od 1 do 20 ter označi vsak tretji element z zvezdico (npr. <code>3*</code>).</li>
<li>Napiši program, ki z <code>while</code> zahteva vnos pozitivnega števila. Če uporabnik vnese negativno število, ga program ponovno vpraša.</li>
<li>Napiši program, ki z <code>do-while</code> izpiše preprost menijski sistem (npr. “1. možnost”, “2. možnost”, “3. možnost”) in uporabnika sprašuje za izbiro, dokler ne vnese <code>0</code>.</li>
<li>Napiši program, ki izračuna vsoto prvih <code>n</code> naravnih števil, kjer <code>n</code> vnese uporabnik.</li>
<li>Napiši program, ki z dvojno zanko izpiše naslednje vzorce:</li>
</ol>
<pre><code>***
**
*
</code></pre>
<pre><code>***
***
***
</code></pre>
<pre><code>**
***
****
</code></pre>
<pre><code>1
12
123
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funkcije"><a class="header" href="#funkcije">Funkcije</a></h1>
<p>Funkcija je poimenovan blok kode, ki opravi določeno nalogo. Z uporabo funkcij razbijemo program na manjše, lažje razumljive dele in se izognemo ponavljanju kode.</p>
<h2 id="definicija-in-klic"><a class="header" href="#definicija-in-klic">Definicija in klic</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int sestej(int a, int b) {
    return a + b;
}

int main() {
    int rezultat = sestej(3, 4);
    std::cout &lt;&lt; "Rezultat: " &lt;&lt; rezultat &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>Funkcija <code>sestej</code> sprejme dva parametra in vrne njuno vsoto. Klic v <code>main</code> uporabi funkcijo kot del izraza.</p>
<ul>
<li>Vrednosti 3 in 4 se kopirajo v parametra <code>a</code> in <code>b</code>.</li>
<li><code>return</code> zaključi funkcijo in vrne rezultat nazaj klicatelju.</li>
</ul>
<h2 id="parametri-in-vrednosti"><a class="header" href="#parametri-in-vrednosti">Parametri in vrednosti</a></h2>
<ul>
<li>Parametri so lokalni znotraj funkcije.</li>
<li>Funkcija lahko sprejme več parametrov.</li>
<li>Tip vrnjene vrednosti se navede pred imenom funkcije.</li>
</ul>
<h2 id="vračanje-void"><a class="header" href="#vračanje-void">Vračanje <code>void</code></a></h2>
<p>Funkcija s tipom <code>void</code> ne vrne vrednosti, temveč izvaja dejanje.</p>
<pre><code class="language-cpp">void pozdravi() {
    std::cout &lt;&lt; "Pozdravljeni!" &lt;&lt; std::endl;
}
</code></pre>
<h2 id="prenos-po-vrednosti-in-referenci"><a class="header" href="#prenos-po-vrednosti-in-referenci">Prenos po vrednosti in referenci</a></h2>
<p>Privzeto se parametri kopirajo (prenos po vrednosti). Z referencami (<code>&amp;</code>) delimo isti objekt.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void povecaj(int&amp; x) {
    x++;
}

void povecaj_kopija(int x) {
    x++;
}

int main() {
    int stevilo = 5;
    povecaj_kopija(stevilo);
    // Izpiše 5, saj smo kopirali vrednost 5 v funkcijo,
    // v funkciji smo spremenili vrednost kopije, ta se ni shranila
    std::cout &lt;&lt; stevilo &lt;&lt; std::endl;
    povecaj(stevilo);
    // Izpiše 6, saj smo poslali referenco,
    // spremembe znotraj funkcije se shranijo, ker ne delamo s kopijami
    std::cout &lt;&lt; stevilo &lt;&lt; std::endl;
}
</code></pre>
<ul>
<li>Referenca <code>int&amp; x</code> kaže na isto spremenljivko kot <code>stevilo</code>. Spremembe v funkciji se odrazijo pri klicatelju.</li>
</ul>
<h2 id="naloge-3"><a class="header" href="#naloge-3">Naloge</a></h2>
<ol>
<li>Napiši funkcijo, ki ima tri celoštevilske parametre <code>x</code>, <code>y</code> in <code>z</code>. Funkcija naj vrne največjo izmed števil. V <code>main</code> jo preizkusi z različnimi kombinacijami.</li>
<li>Ustvari funkcijo <code>podvoji</code>, ki pomnoži število s številom 2, če je vhodno število deljivo s 3 (funkcija bo tipa <code>void</code> in dobi kot vhod število po referenci). V <code>main</code> jo preizkusi ter preveri, da se spremembe shranijo.</li>
<li>Napiši funkcijo <code>jePrastevilo</code>, ki kot vhod dobi celo število in vrne, ali je število praštevilo.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polja"><a class="header" href="#polja">Polja</a></h1>
<p>Polje shrani zbirko vrednosti enakega tipa v zaporednih pomnilniških mestih. Uporabimo ga, ko vnaprej vemo velikost zbirke.</p>
<h2 id="statična-polja"><a class="header" href="#statična-polja">Statična polja</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int ocene[5] = {5, 4, 5, 3, 4};

    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; "Ocena " &lt;&lt; i &lt;&lt; ": " &lt;&lt; ocene[i] &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
<ul>
<li>Indeksiranje se začne z 0.</li>
<li>Velikost polja mora biti znana ob prevajanju.</li>
<li>Če deklariramo polje <code>int ocene[5];</code> brez vrednosti, vsebuje nedoločene podatke.</li>
</ul>
<h2 id="inicializacija-in-privzete-vrednosti"><a class="header" href="#inicializacija-in-privzete-vrednosti">Inicializacija in privzete vrednosti</a></h2>
<p>Če polje inicializiramo delno, preostanek zapolni <code>0</code> (za številske tipe).</p>
<pre><code class="language-cpp">int stevila[4] = {1, 2}; // Ostala elementa postaneta 0
</code></pre>
<ul>
<li>Vrednosti, ki jih ne navedemo, se zaradi standarda C++ samodejno nastavijo na nič.</li>
</ul>
<h2 id="dostop-do-elementov"><a class="header" href="#dostop-do-elementov">Dostop do elementov</a></h2>
<p>Elemente polja beremo in spreminjamo z oglatimi oklepaji, pri čemer indeks začnemo šteti pri 0.</p>
<pre><code class="language-cpp">int vrednosti[3] = {4, 6, 8};
vrednosti[0] = 10;           // prvi element postane 10
int zadnji = vrednosti[2];   // preberemo tretji element
</code></pre>
<ul>
<li>Pazimo, da ne dostopamo izven meja (<code>vrednosti[3]</code> bi bil neveljaven).</li>
<li>Dolžino polja običajno hranimo v dodatni spremenljivki ali pa jo poznamo iz konteksta.</li>
</ul>
<h2 id="dvodimenzionalna-polja"><a class="header" href="#dvodimenzionalna-polja">Dvodimenzionalna polja</a></h2>
<p>Polje lahko predstavlja tudi mrežo. Takrat uporabimo dve velikosti: vrstice in stolpce.</p>
<pre><code class="language-cpp">int mreza[3][4]; // 3 vrstice, 4 stolpci

for (int i = 0; i &lt; 3; i++) {
    for (int j = 0; j &lt; 4; j++) {
        mreza[i][j] = i + j; // dostop do elementa na mestu (i, j)
    }
}
</code></pre>
<ul>
<li>Prvi indeks (i) izbere vrstico, drugi (j) stolpec.</li>
<li>Notranja zanka se običajno sprehodi čez stolpce, zunanja pa po vrsticah.</li>
<li>Za izpis dodamo <code>std::cout &lt;&lt; mreza[i][j] &lt;&lt; " ";</code> v notranjo zanko in <code>std::cout &lt;&lt; std::endl;</code> po njej, da dobimo lepo oblikovane vrstice.</li>
</ul>
<h2 id="nizi-znakov-in-0"><a class="header" href="#nizi-znakov-in-0">Nizi znakov in <code>\0</code></a></h2>
<p>Znaki (<code>char</code>) se lahko hranijo v polju. Polje znakov je niz.</p>
<pre><code class="language-cpp">char pozdrav[6] = {'Z', 'd', 'r', 'a', 'v', '\0'};
// enakovredno: char pozdrav[6] = "Zdrav";
</code></pre>
<ul>
<li>Prevajalnik sam doda <code>\0</code>, če uporabimo dvojne narekovaje; vseeno moramo rezervirati prostor zanj.</li>
<li>Če <code>\0</code> manjka, funkcije, kot je <code>std::cout &lt;&lt; pozdrav</code>, ne vedo, kje se niz konča.</li>
</ul>
<h2 id="naloge-4"><a class="header" href="#naloge-4">Naloge</a></h2>
<ol>
<li>Napiši program, ki prebere pet celih števil v polje in izpiše najvišjo ter najnižjo vrednost.</li>
<li>Ustvari funkcijo <code>int vsotaTretin(const int polje[], int velikost)</code>, ki sešteje vsak tretji element (indeksi 0, 3, 6 ...). Funkcijo preizkusi na nekaj primerih.</li>
<li>Ustvari polje velikosti <code>10x10</code>. Napolni ga tako, da je element <code>[i][j]</code> enak <code>j</code> (torej števila od 0 do 9). Nato izračunaj vsoto glavne diagonale (<code>[0][0]</code>, <code>[1][1]</code> ...).</li>
<li>Napiši program, ki prebere število vrstic in stolpcev, ustvari 2D polje ter vsak element zapolni z znakom <code>*</code>. Na koncu polje izpiši.</li>
<li>Dopolni rešitev prejšnje naloge tako, da lahko uporabnik izbere simbol, s katerim se polje polni.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kazalci"><a class="header" href="#kazalci">Kazalci</a></h1>
<p>Kazalec (pointer) hrani pomnilniški naslov vrednosti. Omogoča neposreden dostop do podatkov na določenem mestu v pomnilniku, kar je močno orodje, a zahteva natančnost.</p>
<h2 id="osnovna-sintaksa"><a class="header" href="#osnovna-sintaksa">Osnovna sintaksa</a></h2>
<pre><code class="language-cpp">int vrednost = 42;
int* kazalec = &amp;vrednost; // kazalec hrani naslov spremenljivke

std::cout &lt;&lt; "Vrednost: " &lt;&lt; vrednost &lt;&lt; std::endl;
std::cout &lt;&lt; "Naslov: " &lt;&lt; kazalec &lt;&lt; std::endl;
std::cout &lt;&lt; "Dostop preko kazalca: " &lt;&lt; *kazalec &lt;&lt; std::endl;
</code></pre>
<ul>
<li>Operator <code>&amp;</code> vrne naslov spremenljivke, operator <code>*</code> pa dereferencira kazalec (dostop do vsebine na naslovu).</li>
<li>Naslov, izpisan na zaslon, se običajno prikaže v šestnajstiškem zapisu.</li>
</ul>
<h2 id="kazalci-in-funkcije"><a class="header" href="#kazalci-in-funkcije">Kazalci in funkcije</a></h2>
<p>Kazalce pogosto uporabimo, ko želimo, da funkcija spremeni podatek.</p>
<pre><code class="language-cpp">void nastaviNaNic(int* ptr) {
    if (ptr != nullptr) {
        *ptr = 0;
    }
}

int main() {
    int stevilo = 7;
    nastaviNaNic(&amp;stevilo);
    std::cout &lt;&lt; "Število: " &lt;&lt; stevilo &lt;&lt; std::endl; // Izpiše 0
}
</code></pre>
<p><code>nullptr</code> predstavlja prazen kazalec, ki ne kaže nikamor.</p>
<ul>
<li>Preden dereferenčiramo kazalec (<code>*ptr</code>), preverimo, ali ni <code>nullptr</code>, da se izognemo nedoločenemu obnašanju.</li>
<li>Funkcija prejme naslov spremenljivke z uporabo operatorja <code>&amp;</code>.</li>
</ul>
<h2 id="dinamična-dodelitev"><a class="header" href="#dinamična-dodelitev">Dinamična dodelitev</a></h2>
<p><code>new</code> rezervira prostor v pomnilniku, <code>delete</code> pa ga vrne sistemu. Za vsak <code>new</code> mora obstajati ustrezen <code>delete</code>.</p>
<pre><code class="language-cpp">int* podatki = new int[3];
podatki[0] = 1;
podatki[1] = 2;
podatki[2] = 3;

for (int i = 0; i &lt; 3; i++) {
    std::cout &lt;&lt; podatki[i] &lt;&lt; std::endl;
}

delete[] podatki; // Sprosti polje
</code></pre>
<ul>
<li><code>new int[3]</code> ustvari dinamično polje; uporabljamo ga, ko velikost poznamo šele med izvajanjem.</li>
<li><code>delete[]</code> mora imeti enake oglate oklepaje kot <code>new[]</code>, sicer sproščanje ni pravilno.</li>
</ul>
<p>Pri delu z dinamičnim pomnilnikom pazimo na uhajanje pomnilnika in dostop do že sproščenih podatkov. V sodobnem C++ raje uporabljamo pametne kazalce (<code>std::unique_ptr</code>, <code>std::shared_ptr</code>), ki avtomatizirajo sproščanje.</p>
<h2 id="kazalci-in-polja"><a class="header" href="#kazalci-in-polja">Kazalci in polja</a></h2>
<p>Ime polja se v izrazih razstavi v kazalec na prvi element. To pojasni, zakaj <code>sizeof</code> na kazalcu ne vrne velikosti polja.</p>
<pre><code class="language-cpp">int vrednosti[3] = {10, 20, 30};
int* p = vrednosti; // enakovredno &amp;vrednosti[0]

std::cout &lt;&lt; *(p + 1) &lt;&lt; std::endl; // Izpiše 20
</code></pre>
<ul>
<li>Izraz <code>p + 1</code> premakne kazalec za en element naprej (upošteva velikost tipa <code>int</code>).</li>
<li><code>*(p + i)</code> je enakovredno <code>p[i]</code>.</li>
</ul>
<h2 id="naloge-5"><a class="header" href="#naloge-5">Naloge</a></h2>
<ol>
<li>Napiši program, ki uporablja kazalec za zamenjavo vrednosti dveh spremenljivk.</li>
<li>Ustvari funkcijo, ki prejme kazalec na <code>int</code> in ga, če ni <code>nullptr</code>, poveča za 10.</li>
<li>Napiši program, ki dinamično ustvari polje velikosti <code>n</code>, ga napolni s kvadrati indeksov in na koncu pravilno sprosti pomnilnik.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
